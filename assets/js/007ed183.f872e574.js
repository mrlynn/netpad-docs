"use strict";(self.webpackChunkdocs_netpad_io=self.webpackChunkdocs_netpad_io||[]).push([[5789],{8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>o});var i=s(6540);const t={},d=i.createContext(t);function r(e){const n=i.useContext(d);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(d.Provider,{value:n},e.children)}},9131:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"developer/extending-netpad","title":"Extending NetPad: Adding New Shape Types","description":"NetPad is designed to be extensible. You can add new shape types to the editor by following these steps:","source":"@site/docs/developer/extending-netpad.md","sourceDirName":"developer","slug":"/developer/extending-netpad","permalink":"/docs/developer/extending-netpad","draft":false,"unlisted":false,"editUrl":"https://github.com/mrlynn/netpad-v3/tree/main/docs/docs/developer/extending-netpad.md","tags":[],"version":"current","frontMatter":{}}');var t=s(4848),d=s(8453);const r={},o="Extending NetPad: Adding New Shape Types",a={},l=[{value:"1. Define the Shape Type",id:"1-define-the-shape-type",level:2},{value:"2. Register the Shape",id:"2-register-the-shape",level:2},{value:"3. Update Shape Creation",id:"3-update-shape-creation",level:2},{value:"4. Rendering Logic",id:"4-rendering-logic",level:2},{value:"5. Connectors",id:"5-connectors",level:2},{value:"6. Bounding Box",id:"6-bounding-box",level:2},{value:"7. Properties Panel",id:"7-properties-panel",level:2},{value:"8. Palette",id:"8-palette",level:2},{value:"9. Behaviors",id:"9-behaviors",level:2},{value:"10. Testing",id:"10-testing",level:2},{value:"Best Practices",id:"best-practices",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,d.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"extending-netpad-adding-new-shape-types",children:"Extending NetPad: Adding New Shape Types"})}),"\n",(0,t.jsx)(n.p,{children:"NetPad is designed to be extensible. You can add new shape types to the editor by following these steps:"}),"\n",(0,t.jsx)(n.h2,{id:"1-define-the-shape-type",children:"1. Define the Shape Type"}),"\n",(0,t.jsxs)(n.p,{children:["Add a new entry to ",(0,t.jsx)(n.code,{children:"ShapeTypes"})," in ",(0,t.jsx)(n.code,{children:"src/models/Shape.js"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export const ShapeTypes = {\n  ...\n  HEXAGON: 'hexagon',\n  // ...\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"2-register-the-shape",children:"2. Register the Shape"}),"\n",(0,t.jsxs)(n.p,{children:["Add a new entry to ",(0,t.jsx)(n.code,{children:"shapeRegistry"})," in ",(0,t.jsx)(n.code,{children:"src/models/Shape.js"})," with default properties:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"[ShapeTypes.HEXAGON]: {\n  displayName: 'Hexagon',\n  defaultProps: {\n    ...BaseShapeDefaults,\n    type: ShapeTypes.HEXAGON,\n    width: 100,\n    height: 80,\n    label: 'Hexagon',\n    fill: '#e0e0e0',\n    stroke: '#333',\n    strokeWidth: 2,\n  },\n},\n"})}),"\n",(0,t.jsx)(n.h2,{id:"3-update-shape-creation",children:"3. Update Shape Creation"}),"\n",(0,t.jsxs)(n.p,{children:["Update ",(0,t.jsx)(n.code,{children:"getNewShape"})," in ",(0,t.jsx)(n.code,{children:"Canvas.js"})," to support the new type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"case ShapeTypes.HEXAGON:\ncase 'hexagon':\n  return createShape(ShapeTypes.HEXAGON, { id, x, y });\n"})}),"\n",(0,t.jsx)(n.h2,{id:"4-rendering-logic",children:"4. Rendering Logic"}),"\n",(0,t.jsxs)(n.p,{children:["In ",(0,t.jsx)(n.code,{children:"Canvas.js"}),", add a rendering block for the new shape in the main render loop:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use SVG primitives (e.g., ",(0,t.jsx)(n.code,{children:"<polygon>"}),", ",(0,t.jsx)(n.code,{children:"<ellipse>"}),", ",(0,t.jsx)(n.code,{children:"<rect>"}),", ",(0,t.jsx)(n.code,{children:"<path>"}),") to draw the shape."]}),"\n",(0,t.jsx)(n.li,{children:"Render the label, connectors, and resize handles as for other shapes."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"5-connectors",children:"5. Connectors"}),"\n",(0,t.jsxs)(n.p,{children:["Update ",(0,t.jsx)(n.code,{children:"getConnectors"})," in ",(0,t.jsx)(n.code,{children:"Canvas.js"})," to return connector points for the new shape:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"For polygons, calculate connector points at logical positions (e.g., vertices, midpoints)."}),"\n",(0,t.jsx)(n.li,{children:"Example for hexagon:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"else if (shape.type === 'hexagon') {\n  // Calculate 6 connector points\n  return { ... };\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"6-bounding-box",children:"6. Bounding Box"}),"\n",(0,t.jsxs)(n.p,{children:["Update ",(0,t.jsx)(n.code,{children:"shapeBounds"})," in ",(0,t.jsx)(n.code,{children:"Canvas.js"})," to return the correct bounding box for the new shape. This is used for selection and marquee logic."]}),"\n",(0,t.jsx)(n.h2,{id:"7-properties-panel",children:"7. Properties Panel"}),"\n",(0,t.jsxs)(n.p,{children:["If the shape has unique properties, update ",(0,t.jsx)(n.code,{children:"PropertiesPanel.js"})," to allow editing them."]}),"\n",(0,t.jsx)(n.h2,{id:"8-palette",children:"8. Palette"}),"\n",(0,t.jsxs)(n.p,{children:["Add the new shape to ",(0,t.jsx)(n.code,{children:"ShapePalette.js"})," with an icon and label."]}),"\n",(0,t.jsx)(n.h2,{id:"9-behaviors",children:"9. Behaviors"}),"\n",(0,t.jsx)(n.p,{children:"Ensure the shape supports selection, dragging, resizing, connectors, copy/paste, and export. Test group selection, marquee, and property editing for the new shape."}),"\n",(0,t.jsx)(n.h2,{id:"10-testing",children:"10. Testing"}),"\n",(0,t.jsx)(n.p,{children:"Test the new shape in the editor for all behaviors: creation, selection, connectors, resizing, copy/paste, export, and persistence."}),"\n",(0,t.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["All shapes should have ",(0,t.jsx)(n.code,{children:"id"}),", ",(0,t.jsx)(n.code,{children:"type"}),", ",(0,t.jsx)(n.code,{children:"x"}),", ",(0,t.jsx)(n.code,{children:"y"}),", ",(0,t.jsx)(n.code,{children:"width"}),", ",(0,t.jsx)(n.code,{children:"height"}),", ",(0,t.jsx)(n.code,{children:"label"}),", ",(0,t.jsx)(n.code,{children:"fill"}),", ",(0,t.jsx)(n.code,{children:"stroke"}),", ",(0,t.jsx)(n.code,{children:"strokeWidth"}),", and any shape-specific properties."]}),"\n",(0,t.jsx)(n.li,{children:"Define logical connector points for each shape."}),"\n",(0,t.jsx)(n.li,{children:"Use modular rendering logic and helper functions for connectors."}),"\n",(0,t.jsx)(n.li,{children:"Ensure all shape properties are serializable to MongoDB Atlas."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);